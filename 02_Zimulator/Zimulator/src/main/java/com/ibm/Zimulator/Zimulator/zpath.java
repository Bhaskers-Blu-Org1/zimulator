package com.ibm.Zimulator.Zimulator;

import java.io.*;
import java.util.*;
import com.ibm.Zimulator.SmallAux.*;
import com.ibm.Zimulator.SmallAux.FA.*;

class zpath extends zobject implements CompiledFileRW
{
    zstop[] Λ_λ;
    
    int m;  // mode: 1=Open, 2=Closed. Defined in InputParse().
    int t;  // type: 1=Plan, 2=Intent.

    /*
      For 'Plan' type: 
    */
    int dwf;  // 0 or 1 flag: For 'Plan' type: discard-when-finished. Last zbox to finish this path will discard it.
    double ViabilityTime; // <0, or else the time after which this zpath is not viable.
    double ExpiryTime;    // <0, or else the time after which other options should be explored.
    
    //    LinkedList<zbox> Followers; // list of zboxen sporting this zpath.   Add followers with AddFollower() below.
    HashSet<zbox> Followers; // list of zboxen sporting this zpath.   Add followers with AddFollower() below.

    double E; // Economy value for this path. Calculated when we resolve.

    ztype e;  // the type of zbox which this path will accommodate.
    Route ZR; // Generated by constructing Route(). Not done until needed. Valid-or-null.

    zsystem Ψ;  // Convenient. :-/  2018-09-14
    
    public boolean IsIntent()
    {
	return(t==2);
    }    
    public boolean IsPlan()
    {
	return(t==1);
    }    

    public zpath(zsystem _Ψ)
    {
	Ψ = _Ψ;
	m=1;  // default is Open.
	t=1;  // default in Plan.
	Followers = new HashSet<zbox>();
	E=0.;
	ZR=null;
	dwf=0;
	ViabilityTime=-1.0;
	ExpiryTime=-1.0;
    }


    public void AddPathRefsToZboxen()
    {
	int klim = Λ_λ.length;
	for (int k=0;k<klim;k++)
	    {
		if (Λ_λ[k].φ==null) {continue;}
		if (Λ_λ[k].φ.PathsWhoStopHere == null)
		    {
			Λ_λ[k].φ.PathsWhoStopHere= new HashSet<zpath>();
		    }
		if (!Λ_λ[k].φ.PathsWhoStopHere.contains(this))
		    {
			Λ_λ[k].φ.PathsWhoStopHere.add(this);
		    }
	    }
    }
    
    
    public zpath subpath(int i,int j) // i,j inclusive.
    {
	zpath nzp = new zpath(Ψ);
	nzp.m = 1;
	nzp.t = t;
	nzp.e = e;
	nzp.Λ_λ = new zstop[j-i+1];
	nzp.dwf=0;
	int klim=j-i+1;
	// no need to copy the zstops; just refer to them:
	for (int k=0;k<klim;k++) {nzp.Λ_λ[k] = Λ_λ[i+k];}
	return(nzp);
    }

    /* these zstops are unregistered.
    public zpath(zbox O,zbox D,ztype ZT)
    //Make an intent path.
    {
	m=1;
	t=2;
	Followers = new LinkedList<zbox>();
	E=-1;
	e=ZT;
	ZR=null;
	Λ_λ = new zstop[2];
	Λ_λ[0] = new zstop(O);
	Λ_λ[1] = new zstop(D);
	ViabilityTime=-1.;
	ExpiryTime=-1.;
    }
*/
	
    public String toString()
    {
	String I;
	I="[zpath";
	if ((Label!=null)&&(Str.length(Label)!=0)) { I += " '" + Label +"'";}
	if (Λ_λ==null) {I+=" Λ:{} ";}
	else
	    {
		I += " Stops:" + Λ_λ.length + " Λ:{";
		for (int j=0;j<Λ_λ.length;j++)
		    {
			if (Λ_λ[j]==null) { I += "⌀ "; } else
			    {
				I += j + ":";
				//if (Λ_λ[j].Label!=null) {I += Λ_λ[j].Label;}
				if (Λ_λ[j].φ!=null)
				    {
					if (Λ_λ[j].φ.Label!=null) {I += Λ_λ[j].φ.Label;}
				    }
				if (Λ_λ[j].K!=null)
				    {
					if (Λ_λ[j].K.Label!=null) {I += "|" + Λ_λ[j].K.Label +"|";}
				    }
				I += " ";
			    }
		    }
		I+="} E=" +E;
	    }
	if (Followers!=null)
	    {
		{I += " Followers:{" + Followers.size() + "} "; }		
	    }
	I += "]";
	return(I);
    }




    public String ReportInfo()
    {
	String I="zpath ";
	if (ViabilityTime>=0) {
	    I += " ViabilityTime=" + ViabilityTime + "=" + Str.SecInDayToTime(ViabilityTime) +" "; }
	if (ExpiryTime>=0) {
	    I += " ExpiryTime=" + ExpiryTime + "=" + Str.SecInDayToTime(ExpiryTime) +" "; }
	I += " Type=" ; if (IsPlan()) { I +="P";} else {I+="I";}
	I += " " + ReportStops();
	return(I);
    }

    public String ReportStops()
    { // Only report the stops.
	String nn = "";
	int n=0; // no longer used.
	
	if (n>=0) {nn = "_" + n;}
	String I;
	I="";
	if (Λ_λ!=null)
	    {
		I += " N"+nn+"=" + Λ_λ.length + " ";
		I += " zstops" + nn + "=";
		for (int j=0;j<Λ_λ.length;j++)
		    {
			if (j>0) {I += ",";}
			if (Λ_λ[j].φ!=null)
			    {
				if (Λ_λ[j].φ.Label!=null) {I += Λ_λ[j].φ.Label;}
			    }
			if (Λ_λ[j].K!=null)
			    {
				if (Λ_λ[j].K.Label!=null) {I += "(" + Λ_λ[j].K.Label +")";}
			    }
		    }
	    }
	return(I);
    }

    
    private void discard()
    /*
      This zpath is no longer needed. 
      Let us remove reference to it from all zboxen visited.
     */
    {
	//Str.print("Discarding zpath " + Label);
	for (int j=0;j<Λ_λ.length;j++)
	    {
		if (Λ_λ[j]!=null)
		    {
			zstop zs = Λ_λ[j];
			if (zs.φ!=null)
			    {
				//Str.print("   No longer stopping at:" + zs.φ.Label);
				if (null != zs.φ.PathsWhoStopHere)
				    {
					zs.φ.PathsWhoStopHere.remove(this);
				    }
			    }
		    }
	    }
    }
    
    void AddToLists()
    {
	Ψ.System_Z_Lists.add_to_BufferS(this);	
	/*
	for (int q=0;q<Λ_λ.length;q++)
	    {
		Ψ.System_Z_Lists.add_to_BufferS(Λ_λ[q]);
	    }
	*/
    }

    
    public zpath Resolve()
    {
	return(Resolve(e.Eco)); //2018-08-25: Eco was moved to ztype.
    }
    public zpath Resolve(Economics Eco)
    /*
      Resolve on an 'Intent'-type zpath generates a 'Plan' type zpath.
      It will be the most economical one, if there is a choice.
      It will be a path suitable for an (A,n) zbox with the given CostFactor.
      Does NOT include cost of very last zbox on path.
     */
    {
	if (IsPlan()) {return(this);} // we are already a plan. ! We could calculate economy though.
	if (Λ_λ.length==1)
	    {
		return(this);  // Shouldn't have this, really.
	    }
	zpath zpa = null; // Accumulator.
	int ilim = Λ_λ.length-1;
	if (m==2) { ilim=Λ_λ.length ; } // Closed case.
	int i;
	for (i=0;i<ilim;i++)
	    {
		zpath szp = new zpath(Ψ);
		szp.m = 1;  // Open. A->B
		szp.t = 2;  // Intent.
		szp.e = e;
		szp.Λ_λ = new zstop[2];
		szp.Λ_λ[0] = Λ_λ[i % Λ_λ.length];
		szp.Λ_λ[1] = Λ_λ[(i+1) % Λ_λ.length];
		//Str.print(szp.report(6665));  //Unresolved
		zpath szpr = szp.ResolveSimplePath(Eco);
		//Str.print(szpr.report(6665)); //Resolved
		// Now we have a resolved piece. Glue it onto ours:
		if (szpr==null) { return(null); }  // no path.
		if (zpa==null)
		    {zpa = szpr;}
		else { zpa = zpa.CombineWith(szpr); }
	    } 
	zpa.m = this.m;   // Open or Closed.
	zpa.t = 1; // Plan; not an Intent anymore.
	return(zpa);
    }

    private zpath CombineWith(zpath zp2)
    /*
      Combines the two zpaths. A->B   B->C  will become A->B->C
      Open Mode is assumed for each. this, then zp2.
      The type will be Plan iff both are Plan.
     */
    {
	zpath zp = new zpath(Ψ);
	zp.m = 1;  // Open. A->B
	zp.t = 1;  // Plan.
	if ( (t==2) || (zp2.t==2)) {zp.t = 2;} // Intent;
	zp.Λ_λ = new zstop[Λ_λ.length + zp2.Λ_λ.length];
	for (int i=0;i<Λ_λ.length;i++)
	    {
		zp.Λ_λ[i] = Λ_λ[i];
	    }
	for (int i=0;i<zp2.Λ_λ.length;i++)
	    {
		zp.Λ_λ[Λ_λ.length + i] = zp2.Λ_λ[i];
	    }
	zp.E=E+zp2.E;
	return(zp);
    }






    boolean IsVisited(zbox γ)
    /*
      Checks whether this zbox is visited during the zpath.
      Does not recursively check 'zpath' zstop entries.
    */
    {
	return(OnZpath(γ)>=0);
    }
    
    int OnZpath(zbox γ)
    {
	int j;
	for (j=0;j<Λ_λ.length;j++)
	    {
		if (Λ_λ[j].φ==γ)
		    {
			return(j);
		    }
	    }
	return(-1);    
    }


    public ArrayList<Integer> NextVisited(zbox zb)
    {
	ArrayList<Integer> Boxen = new ArrayList<Integer>();
	int jlim=Λ_λ.length-1;
	if (m==2) {jlim++;}
	for (int j=0;j<jlim;j++)
	    {
		int jj = (j+1) % Λ_λ.length;
		if (Λ_λ[j].φ==zb)
		    {
			if (Λ_λ[jj].φ!=null) {Boxen.add(jj);}
		    }
	    }
	return(Boxen);
    }


    private zpath ResolveSimplePath(Economics Eco)
    /*
      This is the fundamental resolution routine, and resolves a single O-D pair.
      It should ONLY be called for a zpath of length 2.
     */
    {
	int verbose=0;  // 0,1,2,3	
	if (Λ_λ.length!=2)
	    {
		Ψ.Verb.print("ERROR: ResolveSimplePath() requires a zpath of length 2!");
	    }
	// // // Str.print("Resolving simple path: " + this);	
	zbox zb1 = Λ_λ[0].φ;
	zbox zb2 = Λ_λ[1].φ;
	PathResolution R;
	//Str.print("6666 PathResmode 1");
	R = new PathResolution(Ψ,zb1,zb2,e,Eco);
	return(R.ZP); // (null if no paths).
    }
    
    public void AddFollower(zbox γ)
    /*
      Assigns this path to γ. sets i_P=-1.
     */
    {
	if (γ.P!=null)
	    {
		γ.P.Followers.remove(γ);
	    }
	γ.P = this;
	γ.i_P = -1;
	Followers.add(γ);
    }
    public void RemoveFollower(zbox γ)
    {
	if (γ.P != this) {return;}  // Called mistakenly; γ is not following this path.

	//Str.print("::ZPREM zbox " + γ.Label + " removed from zpath." + this);
	Followers.remove(γ);
	γ.P = null;
	γ.i_P = -1;

	/*
	  If there are no followers, this zpath should be removed from systemlists.
	  
	  Was this a path we resolved expecially for this zbox?
	  If so, it can now be discarded.
	*/
	if (Followers.size()==0)
	    {
		//Str.print("Last follower has left this zpath. dwf=" + dwf);
		if (dwf==1)
		    {
			discard();
			Ψ.System_Z_Lists.add_to_BufferD(this);	
		    }
	    }
    }


    
    

    // Estimated times for entry at eash stop. First is zero.
    // These are probably only valid in 'Plan' case.
    // They should be accessed (and calculated) with get_zstop_time().
    //    private double[] Λ_t;
    double get_zstop_time_interval(int idx)
    /*
      Returns -1.0 if no estimate available.
      Otherwise, the time expected to arrive at the specific index,
      from the last one.  (Arrival -> Arrival)
    */
    {
	if (t==2) {return(-1.0);}  // Intent path. We have no way of estimating yet.
	/*
	if (Λ_t==null)
	    {
		Λ_t = new double[Λ_λ.length];
	    }
	*/
	// Estimate the interval.
	if (idx==0) {return(0.0);}
	zstop zs = Λ_λ[idx-1];  // the last one.
	double Δt;
	if (zs.K==null)
	    {
		Δt = zs.φ.TimeToTraverse(e);
	    }
	else
	    {
		// We'll actually be IN a container on this path, so recurse:
		Δt = zs.K.get_zstop_time_interval(zs.K.OnZpath(zs.φ));
	    }
	return(Δt);
    }




    // ******************************************************************
    // Implementation of 'CompiledFileRW'
    // ******************************************************************

    public void WriteToObjFile(PrimitiveDataOut D) throws IOException
    { //    Λ,m,t,dwf,Via,Exp,Fol,E,e,ZR
	/*
	  zpath,Zstops,m,t,dwf,ViaTime,ExpTime,Followers,E,e,ZR,:Label
	 */
 	D.wb('p');  //zpath.
	D.wi(GetFileRefNumber());
	D.wi(Λ_λ.length);
	/*
	  zstops get stored inline.
	 */
	for (int j=0;j<Λ_λ.length;j++)
	    {
		Λ_λ[j].WriteToObjFile(D);
	    }
	D.wb(m);D.wb(t);D.wb(dwf);
	D.wd(ViabilityTime);
	D.wd(ExpiryTime);
	if (Followers!=null)
	    {
		D.wi(Followers.size());
		Iterator<zbox> wif = Followers.iterator();
		while (wif.hasNext()) { D.wi(wif.next().GetFileRefNumber());}
	    }
	else
	    {
		D.wi(0);
	    }
	D.wd(E);
	if (e==null) {D.wi(0);} else {D.wi(e.GetFileRefNumber());} // should not be null.
	if (ZR==null) {D.wb(0);} else {ZR.WriteToObjFile(D);}
	D.ws(Label);
    }
    public void ReadFromObjFile(ArrayList<ObjRef> ORL,PrimitiveDataIn D) throws IOException
    {
	ObjRef OR = new ObjRef(D.ri(),this);
	Λ_λ = new zstop[D.ri()];
	for (int j=0;j<Λ_λ.length;j++)
	    {
		D.rb();  // 's'
		//Str.printE("#535# zstop:#500#" + j + " (" + Str.setUni(D.rb()) + ")");
		Λ_λ[j] = new zstop();
		Λ_λ[j].ReadFromObjFile(ORL,D);
		//Str.printE("          #005#<---");
	    }
	m=D.rb();t=D.rb();dwf=D.rb();
	ViabilityTime=D.rd();
	ExpiryTime=D.rd();
	//Str.printE("     #005#~~~~~   #500# Via=" + ViabilityTime + " Exp=" + ExpiryTime);
	OR.Rifs=new FA_i();
	int F_l = D.ri(); //Followers.
	for (int j=0;j<F_l;j++) { OR.Rifs.add(D.ri()); } // Followers
	E = D.rd();
	OR.Rufs=new FA_i();
	OR.Rufs.set(0,D.ri()); // e
	if (D.rb()!=0) // 0 or 'R'
	    {
		ZR = new Route();
		ZR.ReadFromObjFile(ORL,D);
	    }
	Label = D.rs();
	ORL.add(OR);
    }

    public boolean ResolveObjRefs(ResolveRef RR,ObjRef OR,zsystem Ψ)
    {
	Followers = new HashSet<zbox>();
	for (int j=0;j<OR.Rifs.length;j++) {Followers.add((zbox) RR.getref(OR.Rifs.get(j)));}
	e = (ztype) RR.getref(OR.Rufs.get(0));
	return(true);
    }

    
}
