package com.ibm.Zimulator.Zimulator;

import java.io.*;
import java.util.*;
import com.ibm.Zimulator.SmallAux.*;
import com.ibm.Zimulator.SmallAux.FA.*;

/*
  InputParser implements reading in a system from a 'zsyntax' Source
  file, which is the human-readable structured format described in the
  Specification.

  A running simulation is not saved in this format; it is for input
  only.  The state of a simulated systems is written to an object
  file, which is described in CompiledFileIO.

  A (probably not comprehensive) description of the steps required in
  implementing a new object type appears in 'zobject'.

  Using InputParser():

  1. IP = new InputParser() with current (extant) system labels, containment, and flags.
  
  2. IP.ParseInputFiles() given some file sources for input. This step may be repeated.*

  2. IP.ParseInputContent() given some sourcefile content for input. This step may be repeated.*

  3. SelectVerboseLabels() if needed. Optional.
  
  4. InsertIntozsystem(Ψ) to put objects into system [] lists.
  

  [ * The step may be repeated, but it contains reference-resolution.                ]
  [ Zobjects may not be added which /reference/ zobjects added in later repetitions. ]
  [ i.e. All Label resolution must be possible at the conclusion of a step.          ]

  In the beginning, there was only the utf-8 plaintext input
  format. The idea will be to begin with this format (or maybe others)
  and then an active simulation is started after compiling to the
  object format.

  The 'ZobjRefRes' class here is somewhat sloppy, but these objects are
  discarded after resolving references anyway and the class is local.
*/

class ZsyntaxInputParser
{
    /*     Result of loading is simple:    */

    private ArrayList<zobject> AllLoadedZobjects;  // We load into this, and then send them all to the zsystem.
    private ArrayList<ZobjRefRes> AllLoadedZobjectsRefs;  // Thrown away once we're finished loading.

    // We used to store these locally and then insert (all or none) into zsystem Ψ.
    // Now, when "zsystem" is encountered in zsyntax, we can modify just like others.
    // ( see "zsystem" section below )
    // private double ZS_T_0,ZS_t_0,ZS_t_1,ZS_Δt;
    // private int ZS_R;
    // private ArrayList<ExternalServer> ZS_Ξ;
    private String ZS_Label;
    private int ZS_LabelIdx;

    /*     ****** ** ******* ** *******    */
    public void InsertIntozsystem(double t)
    /*
      't' is time to give all new zobjects.
    */
    {
	InitAllCurrentTimes(t);
	
	// All the things generated by InputParser():
	/* ( see note on "zsystem" above )
	if (ZS_Label!=null)  // zsystem object is provided in source.
	    {
		Ψ.T__0 = ZS_T_0;
		Ψ.t_0 = ZS_t_0;
		Ψ.t_1 = ZS_t_1;
		Ψ.Δt = ZS_Δt;
		Ψ.R = ZS_R;
		Ψ.Label = ZS_Label;
		Ψ.t = Ψ.t_0;
		Ψ.Ξ = ZS_Ξ;
	    }
	*/

	if (Verbose && AllowZobjectReplacement)
	    {
		DumpAllZobjects(" >---> "); //For debugging. Really this is too verbose...
	    }
    
	Ψ.AddFreshlyLoadedObjects(0,AllLoadedZobjects);

	{
	    /*
	      Report on them.
	    */
	    if (Ψ.ReportAllOnceFlag)
		{
		    int zc=0;
		    Iterator<zobject> wif = AllLoadedZobjects.iterator();
		    while (wif.hasNext())
			{
			    zobject zo = wif.next();
			    if (zo instanceof zbox)
				{
				    zbox φ = (zbox) zo;
				    Ψ.Report(-1,φ.ReportInfo(true));
				    zc++;
				}
			} 
		}
	}
    }


    private void DumpAllZobjects(String pref) //debug
    {
	Iterator<ZobjRefRes> witr = AllLoadedZobjectsRefs.iterator();
	while(witr.hasNext())
	    {
		ZobjRefRes zoref = witr.next();
		Ψ.Verb.printE("#345#" + pref + "#252#" + zoref.zo);
	    }
    }
    

    
    private Containment_Controller ZS_ConCon;

    private LowLevelFileReading FR;
    private int ErrorFlag;
    private boolean Verbose;

    private String ReportingNames;
    private ServerFlags DSF;

    private LabelReferencing AllSystemLabels;

    private ZtypeReferencing Ztypes;

    boolean AllowZobjectReplacement;

    ConstantValues CV;

    // Zinpa = new ZsyntaxInputParser(AllSystemLabels,verboseflag>0,false,Ψ);

    zsystem Ψ;
    public ZsyntaxInputParser(LabelReferencing ExtantSystemZobjectLabels,
			      boolean verboseflag,
			      boolean _AllowZobjectReplacement,
			      zsystem _Ψ)
    {
	Ψ = _Ψ;	

	ZS_ConCon = Ψ.ConCon;
	CV = Ψ.CV;   
	AllowZobjectReplacement = _AllowZobjectReplacement;

	//These should not be changed; used explicitly numerically in the code.
	DSF = new ServerFlags(); // A dummy, treated as a static class.
	
	/*
	  All zobjects are loaded and kept in a single array.
	*/
	AllLoadedZobjects = new ArrayList<zobject>();
	/*
	  This array correcponds to 'AllLoadedZobjects' and contains a 'Ref' object corresponding to every loaded zobject.
	*/
	AllLoadedZobjectsRefs = new ArrayList<ZobjRefRes>();

	/*
	  Some properties of the zsystem:
	*/
	ZS_Label = null;  // Stays null if we do not see a [zsystem] object.
	
	// Do not change the following; integer mode values are used throughout the code!
	// String here is used only for parsing input; obviously not for computations.
	//                     1    2    3     4    5   6      7    8
	//ModeNames = Str.split("Span Pipe Shelf Fifo Bag Source Sink Static");

	// User-defined ztype names. We might add to the list.
	Ztypes = Ψ.ZtypeRefs;
	
	Verbose=verboseflag;
	AllSystemLabels = ExtantSystemZobjectLabels;
	if (AllSystemLabels == null)
	    {
		AllSystemLabels = new LabelReferencing();
	    }
	/*
	  Right now, AllSystemLabels is not needed beyond the input parser.
	  Labels are not kept in any persistent list.
	*/
    }


    public void ParseInputSource(Iterator<String> Zsyntax) throws IOException
    /*
      Parse inputs and load all zobjects:
    */
    {
	if (Zsyntax!=null)
	    {
		FR = new LowLevelFileReading(Zsyntax);
		ErrorFlag=0;
		ReadInputObjects();   // Utilises FR.
		Finish_ParsingInputZsyntax();
	    }
    }
    public void ParseInputSources(Iterator<Iterator<String>> inps) throws IOException
    /*
      Parse inputs and load all zobjects:
    */
    {
	if (inps==null) {return;}
	while (inps.hasNext())
	    {
		Iterator<String> Zsyn = inps.next();
		if (Zsyn!=null)
		    {
			FR = new LowLevelFileReading(Zsyn);
			ErrorFlag=0;
			ReadInputObjects();   // Utilises FR.
		    }
	    }
	Finish_ParsingInputZsyntax();
    }



    
    private void Finish_ParsingInputZsyntax() throws IOException
    {
	/*
		  Resolve references made to any zobjects (either ones which were extant, or in this new loaded set)
	*/
	ResolveReferences();
	/*
	  Resolve containment. (φ contains θ) ⇔ (θ is contained in φ)
	*/
	{
	    if (Verbose) {Ψ.Verb.print("Resolving Containment.");}
	    boolean ContResVerb = false;  // = Verbose;
	    ConnectivityResolution.zboxen_containment(AllLoadedZobjects,ContResVerb,ZS_ConCon);
	}
	/*
	  Make sure containment is a tree.
	 */
	CheckForContainmentLegality(AllLoadedZobjects);
	/*
	  Resolve connectivity; zlinks and zboxen consistency.
	 */
	{
	    if (Verbose) {Ψ.Verb.print("Resolving Connectivity: zpaths;zlinks;zboxen.");}
	    ConnectivityResolution.zpaths_zlinks_zboxen(AllLoadedZobjects);
	}
    }


    
    private int GetTypeInteger(String S)
    { // User types from 1... ; 0 means no type.
	if (Str.equals(S,".")) {return(0);}
	int ol = Ztypes.NumTypes();
	int i = Ztypes.A_Str_to_int(S);
	if (Verbose && (ol != Ztypes.NumTypes())) {Ψ.Verb.printrgb("  Define type " + i + " : " + S,3,4,5);}
	return(i);
    }
    

    private void ReadInputObjects()  throws IOException
    {
	while (true)
	    {		
		if (!Read_zobject()) {break;}   // if we see anything but zsyntax, the file is over. :-/ Shuold be an error.
		//Str.print("Line: " + FR.Last_Line_Read());	//DEBUG
		if (Read_zobject_Ref!=null)
		    {
			ErrorExit("Naked reference:" + Read_zobject_Ref );
			break;
		    }
		/*
		  if (Read_zobject_Obj==null)  //might just be an empty line, etc.
		    {
			ErrorExit("Found something which is not zsyntax: '" + FR.Item + "'");
			break;
		    }
		*/
	    }
    }

    private void SetZtype(int A,int n,ztype χ)
    /*
      Define a new ztype, associated with (A,n).
     */
    {
	Ztypes.Set_ztype(A,n,χ);
    }
    private ztype GetZtype(int A,int n)
    {
	if (A==-1) {return(null);}
	if (n<1) {return(null);}
	return(Ztypes.Get_ztype(A,n));
    }
        
    public void InitAllCurrentTimes(double curtime)
    {
	Iterator<zobject> wit = AllLoadedZobjects.listIterator();
	while(wit.hasNext())
	    {
		zobject zo = wit.next();
		if (zo instanceof zbox)
		    {
			zbox φ = (zbox) zo; // No better than a C *void anyway... :-/
			φ.t = curtime;
			//Str.print("ZBOX: " + φ.Label + " t=" + φ.t);
			/*
			  Also initialise space inside each:
			*/
			φ.InitialiseSpaceInside();
		    }
	    }	
    }

    private void CheckForContainmentLegality(ArrayList<zobject> OBS) throws IOException    
    {
	Iterator<zobject> wit = OBS.listIterator();
	while(wit.hasNext())
	    {
		zobject zo = wit.next();
		if (zo instanceof zbox)
                    {
                        zbox φ = (zbox) zo;
			if (φ.z!=null)
			    {
				if (!φ.z.e.CanContain(φ.e))
				    {
					ErrorExit(φ.z.Label +"(" + φ.z.e + ")" + " cannot contain " + φ.Label + "(" + φ.e +")");
				    }
			    }
		    }
	    }
    }
    


    String Read_zobject_Ref;
    zobject Read_zobject_Obj;
    boolean Read_zobject()  throws IOException
    /*
      Reads in the next 'thing':
      * Zobject? Sets the above 'Obj' and sets to null the above 'Ref'. Returns true.
      * Reference? Sets 'Obj' to null, and sets 'Ref' to the reference Label. Returns true.
      * Delimiter? { } etc. -> both Obj and Ref null, and return false.

      If it is neither (i.e. end of a list; hit delimiter, etc.)
      then they will be both null, and false will be returned.
    */
    {
	Read_zobject_Ref=null;
	Read_zobject_Obj=null;
	FR.Read_Item();
	if (FR.Item!=null) {return(false);} // Not a zobject; we expect [ or <.

	if (FR.ItemDel=='<')
	    {
		// REFERENCE
		FR.Read_Item();
		if (FR.ItemDel!='>') {ErrorExit("Reference delimited incorrectly.");}
		//Str.printrgb("Got Reference: <" + FR.Item + ">",3,5,3);
		if (ErrorFlag==1) {return(false);} 
		Read_zobject_Ref=FR.Item;
		FR.Read_Item(); // '>'
		return(true);
	    }

	if (FR.ItemDel=='[')
	    { // A new zobject definition.
	      // [ zobject label var=val  var=val  var=val  var=val ]
		FR.Read_Item();
		// ====================================================
		if (Str.equals(FR.Item,"ztype"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("ztype finished too early?");}
			ztype e = new ztype();
			ZobjRefRes e_Ref = new ZobjRefRes(e);
			// Parse the zbox definition and make assignments, until ']'.
			while (0==0)
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();if (FR.Item==null) {break;} //EoF or ].   (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    { // Not assignment; label.
					// (Maybe do not give ztype a label?? We have A,n. Fine for now.)
					// Ztype is never referenced by label, but maybe a ztype would be modified?
					e = (ztype) FetchLabelAndAssignZobject(e_Ref,FR.Item);
					if (Verbose) {Ψ.Verb.printrgb("# ztype '" + e.Label + "' (" + e_Ref.LabelIdx + ")",1,1,5);}
				    }
				else
				    { // An assignment, since '=' is there.
					//Str.printrgb("Got Assignment: " + FR.Item + "=...",3,5,3);
					// This would be nicer in C :-/
					if (Str.equals(FR.Item,"R"))
					    { // Reporting Mode.
						FR.Read_Item();
						e.R = new ReportFlags(FR.Item);
						continue;
					    }
					if (Str.equals(FR.Item,"A")) 
					    {
						FR.Read_Item();e.A = GetTypeInteger(FR.Item);
						continue;
					    }
					if (Str.equals(FR.Item,"n")) { FR.Read_Item();e.n = Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"C"))
					    { // List of possible types we can contain.
						FR.Read_Item();
						if (FR.ItemDel!='{') {ErrorExit("List Expected.");}
						FA_i C_A = new FA_i();
						FA_i C_n = new FA_i();
						FA_i C_ξ = new FA_i();
						Iterator<String[]> wil = new ListIter(2); // (A,n) or (A,n,ξ).
						int j=0;
						while (wil.hasNext())   // New way; flexible lists.
						    {
							String[] entry = wil.next();
							C_A.set(j,GetTypeInteger(entry[0]));
							C_n.set(j,Str.atoi(entry[1]));
							if (entry.length>2)
							    {
								C_ξ.set(j,DSF.ValueFromMask(entry[2]));
								// Olde way 2018-09-07: C_ξ.set(j,SelectBits(entry[2],ServerConsultationFlags));
							    }
							j++;
						    }
						e.C_A = C_A.toArray();
						e.C_n = C_n.toArray(C_A.length);
						e.C_ξ = C_ξ.toArray(C_A.length);
						continue;
					    }
					if (Str.equals(FR.Item,"Z"))
					    { // List of possible types we can sleep in.
						FR.Read_Item();if (FR.ItemDel!='{') {ErrorExit("List Expected.");}
						FA_i Z_A = new FA_i();
						FA_i Z_n = new FA_i();
						Iterator<String[]> wil = new ListIter(2); // (A,n)
						int j=0;
						while (wil.hasNext())
						    {
							String[] entry = wil.next();
                                                        Z_A.set(j,GetTypeInteger(entry[0]));
                                                        Z_n.set(j,Str.atoi(entry[1]));
							j++;
						    }
						e.Z_A = Z_A.toArray();
						e.Z_n = Z_n.toArray(Z_A.length);
						continue;
					    }
					if (Str.equals(FR.Item,"m"))
					    { // Containment Mode.
						FR.Read_Item();
						e.m = Select(FR.Item,CV.ModeNames); // defined there.
						if (e.m==0) {ErrorExit("Bad mode.");}
						continue;
					    }
					if (Str.equals(FR.Item,"q")) {FR.Read_Item();e.q=Str.atoi(FR.Item);continue;} // added on 2018-05-02.
					if (Str.equals(FR.Item,"L")) {FR.Read_Item();e.L=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"W")) {FR.Read_Item();e.W=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"N")) {FR.Read_Item();e.N=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"S")) {FR.Read_Item();e.S=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"σ") || Str.equals(FR.Item,"sigma"))
					    {FR.Read_Item();e.σ=Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"$")) {FR.Read_Item();e.BaseCost=Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"$f")) {FR.Read_Item();e.CostFactor=Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"V")) {FR.Read_Item();e.V=Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"l")) {FR.Read_Item();e.l=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"v")) {FR.Read_Item();e.v=Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"ρ") || Str.equals(FR.Item,"rho")) {FR.Read_Item();e.ρ=Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"ρ_0") || Str.equals(FR.Item,"rho_0")) {FR.Read_Item();e.ρ_0=Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"χ") || Str.equals(FR.Item,"chi"))
					    {
						if (!Read_zobject()) {ErrorExit("zlink expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zlink)) ) {ErrorExit("zlink expected.");}
						e.χ = (zlink) Read_zobject_Obj;
						e_Ref.χ = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"ξ")||Str.equals(FR.Item,"xi"))
					    {
						FR.Read_Item();
						e.ξ = new ServerFlags(FR.Item);
						// Olde way 2018-09-07: e.ξ = SelectBits(FR.Item,ServerConsultationFlags);
						continue;
					    }
					// 2018-09-07:  Removed.
					//if (Str.equals(FR.Item,"n_ξ")||Str.equals(FR.Item,"n_xi"))
					//{FR.Read_Item();e.n_ξ=Str.atoi(FR.Item);continue;}

					//2018-08-25: Economy moved to ztype from zschedule and zdemand.
					if (CheckEconomyCoefficients(e.Eco)) {continue;}
					
					ErrorExit("ztype Unrecognised parameter " +FR.Item);
				    }// Assignment.
			    } // Items inside zbox [...]
			if (ErrorFlag==1) {e=null;} 
			SetZtype(e.A,e.n,e);   // register this type in the A,n list.

			Read_zobject_Obj=e;
			Read_zobject_Ref=null;
			AllLoadedZobjects.add(Read_zobject_Obj);
			AllLoadedZobjectsRefs.add(e_Ref);
			// Register in out ztype reference list:
			return(true);
		    } // we made a new ztype.
		// ====================================================
		if (Str.equals(FR.Item,"zbox") || Str.equals(FR.Item,"zb"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("zbox finished too early?");}
			zbox φ = new zbox(Ψ); // Sets default zbox.
			ZobjRefRes φ_Ref = new ZobjRefRes(φ);
			FA_S φ_Refs = new FA_S();
			// Parse the zbox definition and make assignments, until ']'.
			while (0==0)
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();if (FR.Item==null) {break;} //EoF or ].  (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    {
					/*
					  This is not an assignment. We assume it is a label.
					*/
					φ = (zbox) FetchLabelAndAssignZobject(φ_Ref,FR.Item);
					// The olde way, before Fetch() implemented.
					// φ.Label = FR.Item;
					// φ_Ref.LabelIdx = Ref_DefineLabel(FR.Item,φ);
					if (Verbose) {Ψ.Verb.printrgb("# zbox '" + φ.Label + "' (" + φ_Ref.LabelIdx + ")",1,1,5);}
				    }
				else
				    { // An assignment, since '=' is there.
					//Str.printrgb("Got Assignment: " + FR.Item + "=...",3,5,3);
					// This would be nicer in C :-/
					if (Str.equals(FR.Item,"R"))
					    { // Reporting Mode.
						FR.Read_Item();
						φ.R = new ReportFlags(FR.Item);
						continue;
					    }
					if (Str.equals(FR.Item,"A")) {FR.Read_Item();φ_Ref.A=GetTypeInteger(FR.Item);continue;}
					if (Str.equals(FR.Item,"n")) {FR.Read_Item();φ_Ref.n=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"L")) {FR.Read_Item();φ.set_L(Str.atoi(FR.Item));continue;}
					if (Str.equals(FR.Item,"W")) {FR.Read_Item();φ.set_W(Str.atoi(FR.Item));continue;}
					if (Str.equals(FR.Item,"N")) {FR.Read_Item();φ.set_N(Str.atoi(FR.Item));continue;}
					if (Str.equals(FR.Item,"S")) {FR.Read_Item();φ.set_S(Str.atoi(FR.Item));continue;}
					if (Str.equals(FR.Item,"v")) {FR.Read_Item();φ.set_v(Str.atof(FR.Item));continue;}
					if (Str.equals(FR.Item,"ρ") || Str.equals(FR.Item,"rho")) {FR.Read_Item();φ.set_ρ(Str.atof(FR.Item));continue;}
					if (Str.equals(FR.Item,"π"))
					    {
						FR.Read_Item();int π=Str.atoi(FR.Item);
						if (π==1) {φ.setPrototype();} // Prototype.
						continue;
					    }
					if (Str.equals(FR.Item,"x")) {FR.Read_Item();φ.x=Str.atof(FR.Item);continue;}
					// Information String: (Zbox core does not make use of it.)
					if (Str.equals(FR.Item,"i")) {FR.Read_Item();φ.info = FR.Item;continue;} 
					if (Str.equals(FR.Item,"z"))
					    {
						if (!Read_zobject()) {ErrorExit("zbox expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zbox)) ) {ErrorExit("zbox expected.");}
						φ.z = (zbox) Read_zobject_Obj;
						φ_Ref.z = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"P"))
					    {
						if (!Read_zobject()) {ErrorExit("zpath expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zpath)) ) {ErrorExit("zpath expected.");}
						φ.P = (zpath) Read_zobject_Obj;
						φ_Ref.P = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"i_P")) {FR.Read_Item();φ.i_P=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"Z"))
					    { // List of zboxen.
						FR.Read_Item();
						if (FR.ItemDel!='{') {ErrorExit("List of zboxen Expected.");}
						//LinkedList<zbox> Z = new LinkedList<zbox>();
						LinkedList<Integer> Z_Ref = new LinkedList<Integer>();
						while (Read_zobject()) // list of zboxen
						    {
							if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zbox)) ) {ErrorExit("zbox expected.");}
							zbox noo = (zbox) Read_zobject_Obj;
							int labidx = Ref_ReferenceLabel(Read_zobject_Ref);
							if (labidx==0)
							    {
								if (φ.Z==null) {φ.Z=new ContainmentList(ZS_ConCon);}
								φ.Z.add(noo); // noo.Oval_AddTo(φ.Z);
							    }
							else
							    {
								Z_Ref.add(Ref_ReferenceLabel(Read_zobject_Ref));
							    }
						    }
						//φ.Z = Z; //Z.toArray(new zbox[Z.size()]);
						φ_Ref.Z = Z_Ref; //.toArray(new String[Z_Ref.size()]);
						continue;
					    }
					if (Str.equals(FR.Item,"t")) {ErrorExit("Cannot specify t.");}
					if (Str.equals(FR.Item,"ξ")||Str.equals(FR.Item,"xi"))
					    {
						FR.Read_Item();
						φ.ξ = new ServerFlags(FR.Item);
						//Olde way 2018-09-07: φ.ξ = SelectBits(FR.Item,ServerConsultationFlags);
						//Str.printE("DEBUG: ztype #050#" + φ.Label + "#141# ξ=" + φ.ξ);
						continue;
					    }
					//2018-09-07 Removed:
					//if (Str.equals(FR.Item,"n_ξ")||Str.equals(FR.Item,"n_xi"))
					//{FR.Read_Item();φ.n_ξ=Str.atoi(FR.Item);continue;}

					ErrorExit("zbox Unrecognised parameter " +FR.Item);
				    }// Assignment.
			    } // Items inside zbox [...]
			if (ErrorFlag==1) {φ=null;} 
			Read_zobject_Obj=φ;
			Read_zobject_Ref=null;
			AllLoadedZobjects.add(Read_zobject_Obj);
			AllLoadedZobjectsRefs.add(φ_Ref);
			return(true);
		    } // we made a new zbox.
		// ====================================================
		if (Str.equals(FR.Item,"zsystem"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("zsystem finished too early?");}
			zsystem ZS = Ψ; // For "zsystem" we do not create a new object; we only read in parameters for Ψ.
			while (0==0)
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();
				if (FR.Item==null) {break;} //EoF or ].   (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    { /* Not assignment; label.
					 We cannot use FetchLabelAndAssignZobject() since zsystem is not a zobject.
					 The label must either be fresh (Ψ has no label yet) or equal
					 to the present label (modification. ∃ only one zsystem!)

					 When 'zsystem' is in the input, it can modify the present zsystem if either:
					 1. The Label is exactly the same
					 2. The label is unspecified.
				      */
					if (ZS_Label!=null) {ErrorExit("Multiply-defined label; probably missed '='.");}
					ZS_Label = FR.Item;
					// (zsystem is never referenced except here, and not by label.)
					ZS_LabelIdx = Ref_DefineLabel(ZS_Label,new zobject());   // Dummy Placeholder. (No-one else can use this label)
					if (ZS.Label==null)
					    { // We are apparently defining a fresh zsystem.
						ZS.Label = ZS_Label;
						if (Verbose) {Ψ.Verb.printrgb("# New zsystem '" + ZS_Label + "' (" + ZS_LabelIdx + ")",1,1,5);}
					    }
					else
					    {
						if (!ZS.Label.equals(ZS_Label))
						    {
							ErrorExit("There can only be one zsystem. Cannot have zsystem '" + ZS_Label
								  + "' since extant zsystem is '" + ZS.Label + "'");
						    }
						if (!AllowZobjectReplacement)
						    {
							ErrorExit("There can only be one zsystem in the input.");
						    }
						if (Verbose) {Ψ.Verb.printrgb("# Modifying zsystem '" + ZS.Label + "' (" + ZS_LabelIdx + ")",1,1,5);}						
					    }
				    }
				else
				    { // An assignment, since '=' is there.
					if (Str.equals(FR.Item,"T_0")) {FR.Read_Item();ZS.T__0 = TimeRoutines.ParseDateTime(FR.Item);continue;}
					if (Str.equals(FR.Item,"t_0")) {FR.Read_Item();ZS.t_0 = TimeRoutines.ParseTime(FR.Item);continue;}
					if (Str.equals(FR.Item,"t_1")) {FR.Read_Item();ZS.t_1 = TimeRoutines.ParseTime(FR.Item);continue;}
					if (Str.equals(FR.Item,"Δt"))  {FR.Read_Item();ZS.Δt = TimeRoutines.ParseTime(FR.Item);continue;}
					if (Str.equals(FR.Item,"R"))
					    { // Reporting Mode.
						FR.Read_Item();
						ZS.R = new ReportFlags(FR.Item);
						continue;
					    }
					if (Str.equals(FR.Item,"Ξ") || Str.equals(FR.Item,"Xi"))
					    { // List of servers.
						FR.Read_Item();
						if (FR.ItemDel!='{') {ErrorExit("List Expected.");}
						ZS.Ξ = new ArrayList<ExternalServer>();
						if (Verbose) {Ψ.Verb.printrgb(" Noting external servers...",2,1,5);}
						// Each item is an address. http://... or some such.
						Iterator<String[]> wil = new ListIter(1,false); // just address. Can contain '=' !
						int sc=0;
						while (wil.hasNext())
						    {
							String[] entry = wil.next();
							String ServerAddress = entry[0];
							ZS.Ξ.add(new ExternalServer(Ψ,ServerAddress));
							if (Verbose) {Ψ.Verb.printrgb(" #" +sc+ " [" + ServerAddress + "]",2,3,5);}
							sc++;
						    }
						if (Verbose) {Ψ.Verb.printrgb(" Number of servers referenced: " + ZS.Ξ.size(),2,1,5);}
						continue;
					    }
					
					ErrorExit("Unrecognised parameter " + FR.Item);
				    }// Assignment.
			    } // Items inside [...]
			if (ErrorFlag==1) {return(false);} 
			Read_zobject_Obj=null; //zsystem is special. We have dealt with it directly.
			Read_zobject_Ref=null;
			if (ZS.Label==null)
			    {
				ErrorExit("zsystem must have a label.");
			    }
			return(true);
		    } // we filled in some parameters in Ψ.
		// ====================================================
		if (Str.equals(FR.Item,"zlink") || Str.equals(FR.Item,"zl"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("zlink finished too early?");}
			zlink χ = new zlink(Ψ); // Sets default zlink.
			ZobjRefRes χ_Ref = new ZobjRefRes(χ);
			while (0==0)  // end.
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();
				if (FR.Item==null) {break;} //EoF or ].   (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    { // Not assignment; label.
					χ = (zlink) FetchLabelAndAssignZobject(χ_Ref,FR.Item);
					if (Verbose) {Ψ.Verb.printrgb("# zlink '" + χ.Label + "' (" + χ_Ref.LabelIdx + ")",1,1,5);}
				    }
				else
				    { // An assignment, since '=' is there.
					if (Str.equals(FR.Item,"μ") || Str.equals(FR.Item,"mu"))
					    {
						if (!Read_zobject()) {ErrorExit("zbox expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zbox)) ) {ErrorExit("zbox expected.");}
						χ.μ = (zbox) Read_zobject_Obj;
						χ_Ref.μ = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"ν") || Str.equals(FR.Item,"nu"))
					    {
						if (!Read_zobject()) {ErrorExit("zbox expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zbox)) ) {ErrorExit("zbox expected.");}
						χ.ν = (zbox) Read_zobject_Obj;
						χ_Ref.ν = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"A"))
					    { // List of triples A,n,Δ
						FR.Read_Item();
						if (FR.ItemDel!='{') {ErrorExit("List Expected.");}
						FA_i A_A = new FA_i();
						FA_i A_n = new FA_i();
						FA_i A_Δ = new FA_i();
						Iterator<String[]> wil = new ListIter(3); // (A,n,Δ)
						int j=0;
						while (wil.hasNext())
						    {
							String[] entry = wil.next();
                                                        A_A.set(j,GetTypeInteger(entry[0]));
                                                        A_n.set(j,Str.atoi(entry[1]));
                                                        A_Δ.set(j,Str.atoi(entry[2]));
							j++;
						    }
						χ.A_A = A_A.toArray();
						χ.A_n = A_n.toArray(A_A.length);
						χ.A_Δ = A_Δ.toArray(A_Δ.length);
						continue;
					    }
					ErrorExit("Unrecognised parameter " + FR.Item);
				    }// Assignment.
			    } // Items inside [...]
			if (ErrorFlag==1) {return(false);} 
			Read_zobject_Obj=χ;
			Read_zobject_Ref=null;
			AllLoadedZobjects.add(Read_zobject_Obj);
			AllLoadedZobjectsRefs.add(χ_Ref);
			return(true);
		    } // we made a new zlink
		// ====================================================
		if (Str.equals(FR.Item,"zstop") || Str.equals(FR.Item,"zs"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("zstop finished too early?");}
			zstop S = new zstop(); // Sets default zlink.
			ZobjRefRes S_Ref = new ZobjRefRes(S);
			while (0==0)  // end.
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();
				if (FR.Item==null) {break;} //EoF or ].   (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    { // Not assignment; label.
					S = (zstop) FetchLabelAndAssignZobject(S_Ref,FR.Item);
					if (Verbose) {Ψ.Verb.printrgb("# zstop '" + S.Label + "' (" + S_Ref.LabelIdx + ")",1,1,5);}
				    }
				else
				    { // An assignment, since '=' is there.
					if (Str.equals(FR.Item,"i")) {FR.Read_Item();S.info = FR.Item;continue;} // Info': (Zcore does not use this)
					if (Str.equals(FR.Item,"σ_i")||Str.equals(FR.Item,"sigma_i")) {FR.Read_Item();S.σ_i = Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"σ_f")||Str.equals(FR.Item,"sigma_f")) {FR.Read_Item();S.σ_f = Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"φ") || Str.equals(FR.Item,"phi"))
					    {
						if (!Read_zobject()) {ErrorExit("zbox expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zbox)) ) {ErrorExit("zbox type expected.");}
						S.φ = (zbox) Read_zobject_Obj;
						S_Ref.φ = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"K"))
					    {
						if (!Read_zobject()) {ErrorExit("zpath expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zpath)) ) {ErrorExit("zpath type expected.");}
						S.K = (zpath) Read_zobject_Obj;
						S_Ref.K = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					/*
					  Probably we'll never need μ,ν in input? Resolve them anyway...?
					  Worry about this later.
					 */
					/*
					if (Str.equals(FR.Item,"μ") || Str.equals(FR.Item,"mu"))
					    {
						if (!Read_zobject()) {ErrorExit("zbox expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zbox)) ) {ErrorExit("zbox type expected.");}
						S.μ = (zbox) Read_zobject_Obj;
						S_Ref.μ = Read_zobject_Ref;
						continue;
					    }
					if (Str.equals(FR.Item,"ν") || Str.equals(FR.Item,"nu"))
					    {
						if (!Read_zobject()) {ErrorExit("zbox expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zbox)) ) {ErrorExit("zbox type expected.");}
						S.ν = (zbox) Read_zobject_Obj;
						S_Ref.ν = Read_zobject_Ref;
						continue;
					    }					
					*/
					ErrorExit("Unrecognised parameter " + FR.Item);
				    }// Assignment.
			    } // Items inside [...]
			if (ErrorFlag==1) {return(false);} 
			Read_zobject_Obj=S;
			Read_zobject_Ref=null;
			AllLoadedZobjects.add(Read_zobject_Obj);
			AllLoadedZobjectsRefs.add(S_Ref);
			return(true);
		    } // we made a new zstop
		// ====================================================
		if (Str.equals(FR.Item,"zsource"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("zsource finished too early?");}
			zsource S = new zsource();
			ZobjRefRes S_Ref = new ZobjRefRes(S);
			while (0==0)  // end.
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();
				if (FR.Item==null) {break;} //EoF or ].   (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    { // Not assignment; label.
					S = (zsource) FetchLabelAndAssignZobject(S_Ref,FR.Item);
					if (Verbose) {Ψ.Verb.printrgb("# zsource '" + S.Label + "' (" + S_Ref.LabelIdx + ")",1,1,5);}
				    }
				else
				    { // An assignment, since '=' is there.
					if (Str.equals(FR.Item,"φ") || Str.equals(FR.Item,"phi"))
					    {
						if (!Read_zobject()) {ErrorExit("zbox expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zbox)) ) {ErrorExit("zbox type expected.");}
						S.φ = (zbox) Read_zobject_Obj;
						S_Ref.φ = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"m"))
					    { // Procurement Mode.
						FR.Read_Item();
						S.m = Select(FR.Item,"One From");
						if (S.m==0) {ErrorExit("Bad mode.");}
						continue;
					    }
					if (Str.equals(FR.Item,"o"))
					    { // Origin Mode:
						FR.Read_Item();
						S.o = Select(FR.Item,"Container Teleport");
						if (S.o==0) {ErrorExit("Bad mode.");}
						continue;
					    }
					if (Str.equals(FR.Item,"v_μ")||Str.equals(FR.Item,"v_mu")) {FR.Read_Item();S.v_μ=Str.atof(FR.Item);continue;}
					if (Str.equals(FR.Item,"v_σ")||Str.equals(FR.Item,"v_sigma")) {FR.Read_Item();S.v_σ=Str.atof(FR.Item);continue;}
					
					ErrorExit("Unrecognised parameter " + FR.Item);
				    }// Assignment.
			    } // Items inside [...]
			if (ErrorFlag==1) {return(false);} 
			Read_zobject_Obj=S;
			Read_zobject_Ref=null;
			AllLoadedZobjects.add(Read_zobject_Obj);
			AllLoadedZobjectsRefs.add(S_Ref);
			return(true);
		    } // we made a new zsource
		// ====================================================
		if (Str.equals(FR.Item,"zpath") || Str.equals(FR.Item,"zp"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("zpath finished too early?");}
			zpath K = new zpath(Ψ); // Sets default.
			ZobjRefRes K_Ref = new ZobjRefRes(K);
			while (0==0)
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();
				if (FR.Item==null) {break;} //EoF or ].   (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    { // Not assignment; label.
					K = (zpath) FetchLabelAndAssignZobject(K_Ref,FR.Item);
					if (Verbose) {Ψ.Verb.printrgb("# zpath '" + K.Label + "' (" + K_Ref.LabelIdx + ")",1,1,5);}
				    }
				else
				    { // An assignment, since '=' is there.
					//Str.printrgb("Got Assignment: " + FR.Item + "=...",3,5,3);
					// This would be nicer in C :-/ Probably I just don't know how in Java.
					if (Str.equals(FR.Item,"A")) {FR.Read_Item();K_Ref.A=GetTypeInteger(FR.Item);continue;}
					if (Str.equals(FR.Item,"n")) {FR.Read_Item();K_Ref.n=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"m"))
					    { // Mode.
						FR.Read_Item();
						K.m = Select(FR.Item,"Open Closed");
						if (K.m==0) {ErrorExit("Bad mode.");}
						continue;
					    }
					if (Str.equals(FR.Item,"t"))
					    { // Type
						FR.Read_Item();
						K.t = Select(FR.Item,"Plan Intent");
						if (K.t==0) {ErrorExit("Bad type.");}
						continue;
					    }
					if (Str.equals(FR.Item,"Λ") || Str.equals(FR.Item,"Lambda"))
					    {
						//List: λ,λ, ... just zstops.
						FR.Read_Item();
						if (FR.ItemDel!='{') {ErrorExit("List Expected.");}
						ArrayList<zstop> λ = new ArrayList<zstop>();
						FA_i λ_Ref = new FA_i();
						// Each item is a zstop.
						int j=0;
						while (Read_zobject())
						    {
							if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zstop)) ) {ErrorExit("zstop expected.");}
							λ.add((zstop) Read_zobject_Obj);
							λ_Ref.add(Ref_ReferenceLabel(Read_zobject_Ref));
							j++;
						    }
						if (Verbose) {Ψ.Verb.printrgb(" . . . " +j+ " zstops.",2,1,5);}
						K.Λ_λ = λ.toArray(new zstop[λ.size()]);
						K_Ref.Λ_λ = λ_Ref.toArray();
						continue;
					    }
					ErrorExit("Unrecognised parameter " +FR.Item);
				    }// Assignment.
			    } // Items inside zbox [...]
			if (ErrorFlag==1) {K=null;} 
			Read_zobject_Obj=K;
			Read_zobject_Ref=null;
			AllLoadedZobjects.add(Read_zobject_Obj);
			AllLoadedZobjectsRefs.add(K_Ref);
			return(true);
		    } // we made a new zpath.
		// ====================================================
		if (Str.equals(FR.Item,"zschedule") || Str.equals(FR.Item,"zsch"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("zschedule finished too early?");}
			zschedule H = new zschedule(Ψ); // Sets default.
			ZobjRefRes H_Ref = new ZobjRefRes(H);
			while (0==0)
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();
				if (FR.Item==null) {break;} //EoF or ].   (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    { // Not assignment; label.
					H = (zschedule) FetchLabelAndAssignZobject(H_Ref,FR.Item);
					if (Verbose) {Ψ.Verb.printrgb("# zschedule '" + H.Label + "' (" + H_Ref.LabelIdx + ")",1,1,5);}
				    }
				else
				    { // An assignment, since '=' is there.
					//2018-07-18 removed. if (Str.equals(FR.Item,"R_n")) {FR.Read_Item();H.R_n=Str.atoi(FR.Item);continue;}
					if (Str.equals(FR.Item,"R"))
					    { // Reporting Mode.
						FR.Read_Item();
						H.R = new ReportFlags(FR.Item);
						continue;
					    }
					if (Str.equals(FR.Item,"S"))
					    {
						if (!Read_zobject()) {ErrorExit("zsource expected.");}
						if ( (Read_zobject_Obj!=null)&& (!(Read_zobject_Obj instanceof zsource)) ) {ErrorExit("zsource expected.");}
						H.S = (zsource) Read_zobject_Obj;
						H_Ref.S = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					// A,n removed, since now in zpath. 2018-01-29.
					//if (Str.equals(FR.Item,"A")) {FR.Read_Item();H.A=GetTypeInteger(FR.Item);continue;}
					//if (Str.equals(FR.Item,"n")) {FR.Read_Item();H.n=Str.atoi(FR.Item);continue;}
					//2018-08-25: Eco moved to ztype. if (CheckEconomyCoefficients(H.Eco)) {continue;}
					//2018-07-18 removed. if (Str.equals(FR.Item,"P_r")) {FR.Read_Item();H.ZpathDistnMode = PathDistnMode(FR.Item);continue;}
					if (Str.equals(FR.Item,"T_0")) {FR.Read_Item();H.T_0 = TimeRoutines.ParseTime(FR.Item);continue;}
					if (Str.equals(FR.Item,"P"))
					    {
						if (!Read_zobject()) {ErrorExit("zpath expected.");}
						if ( (Read_zobject_Obj!=null)&&(!(Read_zobject_Obj instanceof zpath)) ) {ErrorExit("zpath expected.");}
						H.P = (zpath) Read_zobject_Obj;
						H_Ref.P = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"T"))
					    { // List of singles T
						FR.Read_Item();
						if (FR.ItemDel!='{') {ErrorExit("List Expected.");}
						FA_d T = new FA_d();
						Iterator<String[]> wil = new ListIter(1); // (A,n,Δ)
						int j=0;
						while (wil.hasNext())
						    {
							String[] entry = wil.next();
							T.set(j,TimeRoutines.ParseTime(entry[0]));
							j++;
						    }
						H.T = T.toArray();
						continue;
					    }
					ErrorExit("Unrecognised parameter " + FR.Item);
				    }// Assignment.
			    } // Items inside [...]
			if (ErrorFlag==1) {return(false);} 
			Read_zobject_Obj=H;
			Read_zobject_Ref=null;
			AllLoadedZobjects.add(Read_zobject_Obj);
			AllLoadedZobjectsRefs.add(H_Ref);
			//Str.print(":::ZS:::" + Read_zobject_Obj);
			return(true);
		    } // we made a new zschedule
		// ====================================================
		if (Str.equals(FR.Item,"zdemand"))
		    {
			if (FR.ItemDel!=' ') {ErrorExit("zdemand finished too early?");}
			zdemand Dem = new zdemand(Ψ); // Sets default.
			ZobjRefRes Dem_Ref = new ZobjRefRes(Dem);
			while (0==0)
			    {
				if (ErrorFlag==1) {break;} 
				FR.Read_Item();
				if (FR.Item==null) {break;} //EoF or ].   (Assumed. Syntax error?)
				if ('='!=FR.ItemDel)
				    { // Not assignment; label.
					Dem = (zdemand) FetchLabelAndAssignZobject(Dem_Ref,FR.Item);
					if (Verbose) {Ψ.Verb.printrgb("# zdemand '" + Dem.Label + "' (" + Dem_Ref.LabelIdx + ")",1,1,5);}
				    }
				else
				    { // An assignment, since '=' is there.
					if (Str.equals(FR.Item,"R"))
					    { // Reporting Mode.
						FR.Read_Item();
						Dem.R = new ReportFlags(FR.Item);
						continue;
					    }
					if (Str.equals(FR.Item,"Reference")) {FR.Read_Item();Dem.Reference=FR.Item;continue;}
					if (Str.equals(FR.Item,"T_0")) {FR.Read_Item();Dem.T_0 = TimeRoutines.ParseTime(FR.Item);continue;}
					//2018-07-18 removed. if (Str.equals(FR.Item,"R_n")) {FR.Read_Item();Dem.R_n=Str.atoi(FR.Item);continue;}
					//2018-08-25: Eco moved to ztype.if (CheckEconomyCoefficients(Dem.Eco)) {continue;}
					//2018-07-18 removed. if (Str.equals(FR.Item,"P_r")) {FR.Read_Item();Dem.ZpathDistnMode = PathDistnMode(FR.Item);continue;}
					if (Str.equals(FR.Item,"Cache")) {FR.Read_Item();Dem.CacheResolvedPaths = Str.equals(FR.Item,"true");continue;}
					if (Str.equals(FR.Item,"S"))
					    {
						if (!Read_zobject()) {ErrorExit("zsource expected.");}
						if ( (Read_zobject_Obj!=null)&& (!(Read_zobject_Obj instanceof zsource)) ) {ErrorExit("zsource expected.");}
						Dem.S = (zsource) Read_zobject_Obj;
						Dem_Ref.S = Ref_ReferenceLabel(Read_zobject_Ref);
						continue;
					    }
					if (Str.equals(FR.Item,"L"))
					    { // List of: zboxen.
						FR.Read_Item();
						if (FR.ItemDel!='{') {ErrorExit("List of zboxen Expected.");}
						ArrayList<zbox> L = new ArrayList<zbox>();
						FA_S L_Ref = new FA_S();
						while (Read_zobject()) // list of zboxen
						    {
							if ( (Read_zobject_Obj!=null)&&
							     (!(Read_zobject_Obj instanceof zbox)) )
							    {ErrorExit("zbox expected.");}
							L.add((zbox) Read_zobject_Obj);
							L_Ref.add(Read_zobject_Ref);   // can contain %s.
						    }
						Dem.L = L.toArray(new zbox[L.size()]);
						Dem_Ref.L = L_Ref.toArray();
						continue;
					    }
					if (Str.equals(FR.Item,"D"))
					    {
						/*
						  Demand list is now a bit flexible.
						  D:  o d T N
						  D5: o d T N v
						  //2018-07-18 removed.  D6: o d T N v P_r
						  //2018-07-18 removed.  D6: o d T N v,v,v,v,v,v... P_r
						  */
						// List of: o,d,T,N ; o,d must be integer indices into L.
						// Maybe also v.
						FR.Read_Item();
						if (FR.ItemDel!='{') {ErrorExit("List of o d T N [v] tuples expected.");}
						
						//  ArrayList<Integer> o = new ArrayList<Integer>();
						//  ArrayList<Integer> d = new ArrayList<Integer>();
						// ArrayList<Double> T = new ArrayList<Double>();
						  //  ArrayList<Integer> N = new ArrayList<Integer>();
						
						  
						  FA_i o = new FA_i();
						  FA_i d = new FA_i();
						  FA_d T = new FA_d();
						  FA_i N = new FA_i();
						
						ArrayList<FA_d> v = new ArrayList<FA_d>();
						Iterator<String[]> wil = new ListIter(4); // (o,d,T,N)
						int j=0;
						while (wil.hasNext())
						    {
							String[] entry = wil.next();
							o.add(Str.atoi(entry[0]));
							d.add(Str.atoi(entry[1]));
							T.add(TimeRoutines.ParseTime(entry[2]));
							//Str.print("TT:" + FR.Item + " -> " + T.get(T.length-1));
							N.add(Str.atoi(entry[3]));
							if (entry.length>4)
							    {
								FA_d OneVel = new FA_d();
								String[] vels = Str.splitCSV(entry[4]);
								for (int l=1;l<vels.length;l++) //start at 1.
								    {
									OneVel.add(Str.atof(vels[l]));
								    }
								v.add(OneVel);
							    }
							j++;
							if (j % 250000 == 0) 
							    {
								Ψ.Verb.print("   zdemand ..." + j);
							    }
						    }
						Dem.o = VtoAi(o);
						Dem.d = VtoAi(d,o.size());
						Dem.T = VtoAd(T,o.size());
						Dem.N = VtoAi(N,o.size());
						if (v.size()>0)
						    {
							Dem.list_v = v;
						    }
						//2018-07-18 removed. if (DemandList>=6) {Dem.list_P_r = VtoA_int(P_r);}
						// Finally, sort them:
						Dem.CalculateOrder();
						continue;
					    }
					ErrorExit("Unrecognised parameter " + FR.Item);					
				    }// Assignment.
			    } // Items inside [...]
			if (ErrorFlag==1) {return(false);} 
			Read_zobject_Obj=Dem;
			Read_zobject_Ref=null;
			AllLoadedZobjects.add(Read_zobject_Obj);
			AllLoadedZobjectsRefs.add(Dem_Ref);
			return(true);
		    } // we made a new zdemand
		// ====================================================
		// Keep adding types of zobject here...=== to ===		
		ErrorExit("Unrecognised Object: " + FR.Item);
	    }//zobject; zbox, zlink, ...
	// No more things. This should only mean we're terminating a list here,
	// or terminating the input stream (which is a list without {}).
	if ((FR.ItemDel!='}')&&(FR.ItemDel!=-1))
	    {
		ErrorExit("Not a proper or zobject definition. {} or delimiters bad, probably.");
	    }
        return(false);
    }

    class ListIter implements Iterator<String[]>
    {
	private int ndef;  // default n or 0 if delimited.
	private String[] nextitem;

	boolean CountEqualsAsDelimiter;

	public ListIter(int n)
	    {
		CountEqualsAsDelimiter=true;
		ndef=n;
		nextitem=null;
		next();  //start it off.
	    }
	public ListIter(int n,boolean EqDel)
	    {
		CountEqualsAsDelimiter=EqDel;  // Allow '=' within things.
		ndef=n;
		nextitem=null;
		next();  //start it off.
	    }
	
	public boolean hasNext()
	{
	    return(nextitem!=null);
	}
	public String[] next()
	{
	    String[] lastnext=nextitem; // will be returned.
	    ArrayList<String> anitem = new ArrayList<String>();
	    FR.Read_Item(CountEqualsAsDelimiter);
	    if (FR.Item==null)
		{
		    nextitem=null; // ending '}'  (Assumed. Syntax error?)
		}
	    else
		{
		    int j=0;
		    if (Str.equals(FR.Item,"/"))
			{
			    ndef=0;
			}
		    else
			{
			    anitem.add(FR.Item);
			    j++;
			}
		    if (ndef!=0)
			{
			    while (j<ndef)
				{
				    FR.Read_Item(CountEqualsAsDelimiter);
				    anitem.add(FR.Item);
				    j++;
				}
			}
		    else
			{
			    while (0==0)
				{
				    FR.Read_Item(CountEqualsAsDelimiter);
				    if (Str.equals(FR.Item,"/")) {break;}
				    anitem.add(FR.Item);
				    j++;
				}
			}
		    // Now we have a j-tuple
		    nextitem = new String[j];
		    for (int k=0;k<j;k++)
			{
			    nextitem[k] = anitem.get(k);
			}
		}
	    
	    if (0==1) //debug.
		{
		    if (lastnext!=null)
			{
			    Str.printn("  :");
			    for (int e=0;e<lastnext.length;e++)
				{
				    Str.printn(" ("+ndef+")[" + lastnext[e] + "]");
				}
			}
		    if (nextitem==null)
			{
			    Str.print("]end]");
			}
		}
	    
	    return(lastnext);
	    
	}
    }



    private zobject FetchLabelAndAssignZobject(ZobjRefRes RR,String Label)  throws IOException
    {
	return(FetchLabelAndAssignZobject(RR,RR.zo,Label,AllowZobjectReplacement));
    }
    private zobject FetchLabelAndAssignZobject(ZobjRefRes RR,zobject zo,String LabelSpec,boolean AllowRepMod)  throws IOException
    /*
      The zobject type has been read, and zo initialised to be of this type.
      zo has been initialised with only this information.
      The Label have been read from input, but not yet assigned to zo.

      AllowRepMod  -- this would be enabled when a server is making a modification to the system.
                      It should not be enabled for loading a zsyntax source file (at least the first one).
      
      The label contains a prefix which determines: Fresh,Replacement,Fresh-or-Replace,Modification,Deletion,Copy-and-Modify.

      If actually an extant zobject is to be modified or replaced, then that zobject will be returned.
      If this is in fact a fresh zobject, we will return it after setting the label.

      RR.LabelIdx will be set.
      RR.zo will be modified if necessary (always to the return value).

      Λ neighbourhood caches
      ----------------------

      When zboxen or zlinks are modified, Λ caches must be invalidated.
      As described in zbox.InvalidateCaches() there are two steps.
      The 'Before' step is performed here, since on return of this function the zobject is modified.
      
    */
    {
	if (zo.Label!=null)
	    { 	// zo should not have a label. If it does, then the
		// label has been erroneously specified more than once.
		ErrorExit("Multiply-defined label; probably '=' is missing.");
	    }
	if (!AllowRepMod)
	    { /*
		Replacement and Modification are not allowed.
	      */
		if (Str.index(":",LabelSpec)!=-1)
		    { // We can only accept a plain Label.
			ErrorExit("Label " + LabelSpec + " may not contain insertion-mode prefix.");
		    }
		// Fresh object. No 'before' Λ invalidation to be performed.
		zo.Label = LabelSpec; // Assign the label.
		RR.LabelIdx = Ref_DefineLabel(LabelSpec,zo);
		return(zo);
	    }
	/*
	  Replacement and Modification are allowed; zo might be a replacement or such. 
	  Check the Label prefix to determine behaviour 'M'.
	*/
	String Label; // The Label without prefix.
	String[] LabelPieces = Str.split(LabelSpec,":"); // the pieces P:Label:etc
	int M,idx=0;
	if (LabelPieces.length>2)
	    {
		M = Str.index("FMDC",LabelPieces[1]);
		Label = LabelPieces[2];
	    }
	else
	    {
		M=4;
		Label = LabelPieces[1];		
	    }
	// Now, M = 0,1,2,3,4 := { F,M,D,C,FoM }
	if (M==4)
	    { // F or M -> 0 or 1.
		idx = Ref_CheckLabelObj(Label);  // Exists AND points to an obj?
		if (idx<1) {M=0;}  // Fresh.
		else {M=1;} // Modify.
	    }

	//DEBUG Str.printE("This #500#zobject#0# might be a replacement or such: #400#LabelSpec=#/#" + LabelSpec + "#0#  #444# => M=" + M);	
	
	if (M==0)
	    { // Fresh.
		// Fresh object. No 'before' Λ invalidation to be performed.		
		zo.Label = Label;
		RR.LabelIdx = Ref_DefineLabel(Label,zo); // Throws exception if Label already taken. We actually should be ignoring the request.
		return(zo);
	    }
	if (M==1)
	    { // Modification
		if (idx<1) {idx = Ref_CheckLabelObj(Label);}   // Slow; do this only if necessary.
		RR.LabelIdx = idx;
		if (RR.LabelIdx<1)
		    {
			ErrorExit("Label " + Label + " not found; modification impossible.");
		    }
		// Switch out an return the extant zobject:
		zo = Ref_GetZobj(RR.LabelIdx);
		RR.zo = zo;
		// Extant object. Λ invalidation to be performed.
		InvalidateZobjectΛ(zo,0);
		return(zo);
	    }
	if (M==2)
	    { // Deletion
		/*
		  Probably the right thing to do here is set a flag so that the object deletes itself,
		  and maybe return null.
		  We allow this to apply to: zbox, zdemand, zschedule, zpath.
		*/
		RR.LabelIdx = Ref_CheckLabelObj(Label);
		if (RR.LabelIdx<1)
		    {
			ErrorExit("Label " + Label + " not found; modification impossible.");
		    }
		// Switch out an return the extant zobject:
		zo = Ref_GetZobj(RR.LabelIdx);
		InvalidateZobjectΛ(zo,0);
		RR.zo = zo;
		return(zo);
	    }
	if (M==3)
	    { // Copy + Modification.
		RR.LabelIdx =  Ref_CheckLabelObj(Label);
		if (RR.LabelIdx<1)
		    {
			ErrorExit("Label " + Label + " not found; copy + modification impossible.");
		    }
		/*
		  We allow this only for zboxen.
		*/
		if (!(zo instanceof zbox))
		    { // treat this like a modification.
			ErrorExit("Label " + Label + " is not a zbox; copy + modification impossible.");
		    }
		/*
		  invoke the copyOf() method
		*/
		zbox φ = (zbox) zo;
		zo = φ.CopyOf(false);  // Will be uncontained. :-/
		zo.Label = LabelPieces[3]; // the fresh label.
		RR.LabelIdx = Ref_DefineLabel(zo.Label,zo);
		// The copy is a fresh object. No 'before' Λ invalidation to be performed.
		RR.zo = zo;
		return(zo);
	    }
	// Execution should never get here.
	ErrorExit("Some kind of problem occurred. Bad Mode. FetchLabelAndAssignZobject()");
	RR.zo=null;
	return(null);  
    }
    

    private void InvalidateZobjectΛ(zobject zo,int BeforeOrAfter)
    {
	Ψ.InvalidateCaches(zo,BeforeOrAfter);
    }


    
    private boolean CheckEconomyCoefficients(Economics Eco)
    // used in both zdemand and zschedule.
    {
	if (Str.equals(FR.Item,"E_T")) {FR.Read_Item();Eco.coeff_T = Str.atof(FR.Item);return(true);}
	if (Str.equals(FR.Item,"E_C")) {FR.Read_Item();Eco.coeff_C = Str.atof(FR.Item);return(true);}
	if (Str.equals(FR.Item,"E_N")) {FR.Read_Item();Eco.coeff_N = Str.atof(FR.Item);return(true);}
	if (Str.equals(FR.Item,"E_L")) {FR.Read_Item();Eco.coeff_L = Str.atof(FR.Item);return(true);}
	if (Str.equals(FR.Item,"E_K")) {FR.Read_Item();Eco.coeff_K = Str.atof(FR.Item);return(true);}
	return(false);
    }

    void ErrorExit(String desc) throws IOException
    {
	Str.printrgb(Str.Repeat("=",80) ,5,3,2);
	Str.printrgb("'" + FR.Last_Line_Read() + "'",5,2,2);
	Str.printE("      #522#*** #400#" + FR.Item + "#522# ***");
	Str.printrgb(Str.Repeat("=",80) ,5,3,2);	
	Str.printrgb("ERROR: " + desc ,5,0,0);
	ErrorFlag=1;
	throw new IOException();
    }
    
    private int Select(String val,String Possibilities)
    {
	return(Select(val,Str.split(Possibilities)));
    }

    private int Select(String val,String[] Possibilities)
    {
	for (int j=1;j<Possibilities.length;j++)
	    {
		if (Str.equals(Possibilities[j],val)) {return(j);}
	    }
	return(0);
    }

    private int SelectBits_XXX(String val,String Possibilities)  // Poss = list of 1,2,4,8,.. values.
    {
	//Str.print("val=[" + val +"] Pos=[" + Possibilities + "]");
	String[] each = Str.split(Possibilities);
	int b=0;
	int bit=1;
	for (int j=1;j<each.length;j++)
	    {
		if (Str.index(val,each[j])!=-1)
		    {
			b += bit;
		    }
		bit *= 2;
	    }
	return(b);
    }
    

    /*
      Generally turning things into arrays. Provide a length optionally.
     */

    private int[] VtoAi(FA_i A)    { return(A.toArray()); }
    private int[] VtoAi(FA_i A,int len)    { return(A.toArray(len)); }
    private double[] VtoAd(FA_d A) { return(A.toArray()); }
    private double[] VtoAd(FA_d A,int len) { return(A.toArray(len)); }
    private int[] VtoAi(ArrayList<Integer> A) { return(VtoAi(A,A.size()));}
    private int[] VtoAi(ArrayList<Integer> A,int len)
    {
	int[] B = new int[len];
	int jlim = len;
	if (jlim>A.size()) {jlim=A.size();}
	for (int j=0;j<jlim;j++)
	    {
		B[j] = A.get(j);
	    }
	return(B);
    }
    private double[] VtoAd(ArrayList<Double> A) { return(VtoAd(A,A.size()));}
    private double[] VtoAd(ArrayList<Double> A,int len)
    {
	double[] B = new double[len];
	int jlim = len;
	if (jlim>A.size()) {jlim=A.size();}
	for (int j=0;j<jlim;j++)
	    {
		B[j] = A.get(j);
	    }
	return(B);
    }






    /*
      Local wrappers to deal with labelling, and maybe throw exceptions.
    */
    private int Ref_DefineLabel(String Label,zobject zo) throws IOException
    {
	int idx = AllSystemLabels.DefineLabel(Label,zo);
	if (idx==-1) {ErrorExit("Label '"+Label+"' Already Defined.");}
	return(idx);
    }
    private int Ref_ReferenceLabel(String Label) throws IOException
    {
	int idx = AllSystemLabels.ReferenceLabel(Label);
	return(idx);
    }
    private int Ref_CheckLabelObj(String Label) throws IOException
    { // Returns idx>0 iff label exists AND points to an object.
	int idx = AllSystemLabels.CheckLabelObj(Label);
	// if (idx<1) {ErrorExit("Object with label '"+Label+"' not found.");}	
	return(idx);
    }
    private zobject Ref_GetZobj(int LabelIdx) throws IOException
    {
	return(Ref_GetZobj(LabelIdx,null));
    }
    private zobject Ref_GetZobj(int LabelIdx,Class C) throws IOException
    {
	zobject zo = AllSystemLabels.ZobjByLabelIdx(LabelIdx);
	if (zo==null)
	    {
		ErrorExit("Reference cannot be resolved. LabelIdx=" + LabelIdx);
	    }
	if (C!=null)
	    {
		if (!(zo.getClass().equals(C)))
		    {
			return(null);
		    }
	    }
	//if (Verbose) {Ψ.Verb.printEn("[#030#" + LabelIdx + "#0#]");}	
	return(zo);
    }


    

    /*
      This enables resolution of references to various zobject types.
      It is highly wasteful, but discarded after loading.
    */
    class ZobjRefRes
    // Resolve some references in a zobject.
    {
	public ZobjRefRes(zobject _zo)
	{
	    zo=_zo;
	}	
	zobject zo;    // the zobject with references.
	int LabelIdx;  // From (index <-> Label) filled by InputParser.	

	// zbox:
	int P;
	int z;
	LinkedList<Integer> Z;
	int A;              // User-defined type.
	int n;              // User-defined number (sub-type)

	// zdemand:
	int S;
	String[] L;   // Strings since can contain %s.

	// zlink:
	int μ,ν;

	// zpath:
	int[] Λ_λ;
	//int A,n; // to determine e from input file.

	// zschedule:
	//int S;
	int φ;
	//int P;

	// zsource:
	//int φ;

	// zstop:
	//int φ;
	int K;

	// ztype:
	int χ;       	
    }
    
    
    private void ResolveReferences()  throws IOException
    {
	// Set by any failure, so we can throw exception at end after error messages output.
	boolean ResolveReferenceFailedFlag = false;

	// Only after loading in input files.
	// I have no idea how to express a class type, so I'll just define these:
	Class C_zbox = new zbox(Ψ).getClass();
	Class C_zlink = new zlink(Ψ).getClass();
	Class C_zstop = new zstop().getClass();
	Class C_zpath = new zpath(Ψ).getClass();
	Class C_ztype = new ztype().getClass();
	Class C_zsource = new zsource().getClass();

	Iterator<ZobjRefRes> witr = AllLoadedZobjectsRefs.listIterator();

	if (Verbose) {Ψ.Verb.print("Resolving References.");}
	while(witr.hasNext())
	    {
		ZobjRefRes zoref = witr.next();
		zobject zo = zoref.zo;
		/*
		  Deal with references in each type of zobject:
		*/
		//if (Verbose) {Ψ.Verb.printEn("[#400#" + zo.Label + "#0#]");}
		
		if (zo instanceof ztype)
		    {
			ztype e = (ztype) zo;
			if (zoref.χ!=0)
			    {
				e.χ = (zlink) Ref_GetZobj(zoref.χ,C_zlink);
				zoref.χ=0;
			    }
		    }
		if (zo instanceof zbox)
		    { // z,Z,S
			zbox φ = (zbox) zo;

			// A,n are references, and they MUST be present.
			if (φ.e==null)
			    {
				φ.e = GetZtype(zoref.A,zoref.n);
				if (φ.e==null)
				    {
					Str.printrgb("Type (" + zoref.A +"," + zoref.n + ") not found for zbox " + φ.Label,5,2,2);
					ResolveReferenceFailedFlag=true;
					break;   // We could just continue, but we would have to deal with e=null and probably crash.
				    }
			    }
			zoref.A=-1;zoref.n=-1;
			
			if (zoref.z!=0)
			    {
				φ.z = (zbox) Ref_GetZobj(zoref.z,C_zbox);
				if (φ.z==φ) {ErrorExit("zbox " + φ.Label + " Is specified as being contained in itself!");}
				zoref.z=0;
			    }
			if (zoref.P!=0)
			    {
				φ.P = (zpath) Ref_GetZobj(zoref.P,C_zpath);
				zoref.P=0;
			    }
			if (zoref.Z!=null)
			    {
				if (φ.Z==null) {φ.Z = new ContainmentList(ZS_ConCon);}
				for (int k=0;k<zoref.Z.size();k++)
				    {
					if (zoref.Z.get(k)!=0)
					    {
						zbox _zi = (zbox) Ref_GetZobj(zoref.Z.get(k),C_zbox);
						φ.Z.add(_zi);  //	_zi.Oval_AddTo(φ.Z);
						zoref.Z.set(k,0);
					    }
				    }
			    }
			zoref.Z=null; // lose whole list.
		    }
		if (zo instanceof zlink)
		    { // μ,ν
			zlink χ = (zlink) zo;
			if (zoref.μ!=0) {χ.μ = (zbox) Ref_GetZobj(zoref.μ,C_zbox); zoref.μ=0;}
			if (zoref.ν!=0) {χ.ν = (zbox) Ref_GetZobj(zoref.ν,C_zbox); zoref.ν=0;}
		    }
		if (zo instanceof zstop)
		    { // φ,K
			zstop S = (zstop) zo;
			if (zoref.φ!=0) {S.φ = (zbox) Ref_GetZobj(zoref.φ,C_zbox); zoref.φ=0;}
			//			if (zoref.μ!=0) {S.μ = (zbox) Ref_GetZobj(zoref.μ,C_zbox); zoref.μ=0;}
			//			if (zoref.ν!=0) {S.ν = (zbox) Ref_GetZobj(zoref.ν,C_zbox); zoref.ν=0;}
			if (zoref.K!=0) {S.K = (zpath) Ref_GetZobj(zoref.K,C_zpath); zoref.K=0;}

			/*
			if (S.K!=null)
			    {
				for (int k=0;k<S.K.Λ_λ.length;k++)
				    { // Not really correct....
					if (S.K.Λ_λ[k].φ==S.μ) {S.i = k;}
					if (S.K.Λ_λ[k].φ==S.ν) {S.j = k;}
				    }
			    }
			*/
		    }
		if (zo instanceof zpath)
		    { // Λ_λ and Λ_S[]
			zpath K = (zpath) zo;

			if (K.e==null)
			    {			
				K.e = GetZtype(zoref.A,zoref.n);
				if (K.e==null)
				    {
					Str.printrgb("Type (" + zoref.A +"," + zoref.n + ") not found for zpath " + K.Label ,5,2,2);
					ResolveReferenceFailedFlag=true;
					break;   // We could just continue, but we would have to deal with e=null and probably crash.
				    }
			    }
			zoref.A=-1;zoref.n=-1;
			
			if (zoref.Λ_λ!=null) // should never be null, actually
			    {
				for (int k=0;k<K.Λ_λ.length;k++)
				    {
					if (zoref.Λ_λ[k]!=0)
					    {
						K.Λ_λ[k] = (zstop) Ref_GetZobj(zoref.Λ_λ[k],C_zstop);
						zoref.Λ_λ[k]=0;
					    }
				    }
				zoref.Λ_λ=null;
			    }
		    }
		if (zo instanceof zschedule)
		    { // φ
			zschedule Sh = (zschedule) zo;
			if (zoref.S!=0) {Sh.S = (zsource) Ref_GetZobj(zoref.S,C_zsource); zoref.S=0;}
			if (zoref.P!=0) {Sh.P = (zpath) Ref_GetZobj(zoref.P,C_zpath); zoref.P=0;}
		    }
		if (zo instanceof zsource)
		    { // φ
			zsource S = (zsource) zo;
			if (zoref.φ!=0)
			    {
				S.φ = (zbox) Ref_GetZobj(zoref.φ,C_zbox); zoref.φ=0;
			    }
		    }

		if (zo instanceof zdemand)
		    {
			zdemand Dem = (zdemand) zo;
			if (zoref.S!=0) {Dem.S = (zsource) Ref_GetZobj(zoref.S,C_zsource); zoref.S=0;}
			if (zoref.L!=null)
			    {
				if (Verbose) {Ψ.Verb.printn("[zdemand: " + zoref.L.length + "] ");}
				for (int k=0;k<zoref.L.length;k++)
				    {
					if (zoref.L[k]!=null)
					    {
						String Ref = Str.replace(Dem.Reference,"%s",zoref.L[k]);
						int RefIdx = Ref_ReferenceLabel(Ref);
						Dem.L[k] = (zbox) Ref_GetZobj(RefIdx,C_zbox);
						if (Dem.L[k]==null)
						    {
							ErrorExit("Cannot resolve " + zoref.L[k]);
						    }
						zoref.L[k]=null;
					    }
				    }
				zoref.L=null;
			    }
		    }
	    }
	//if (Verbose) {Ψ.Verb.printn("\n");}	
	
	if (ResolveReferenceFailedFlag)
	    {
		if (FR.ItemDel!='>') {ErrorExit("There were unresolved references in input.");}
	    }
    }


    
}
